---
phase: 01-content-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/content_file.ts
  - database/migrations/TIMESTAMP_create_content_files_table.ts
  - database/migrations/TIMESTAMP_create_content_content_files_table.ts
  - app/services/file_storage_service.ts
  - app/controllers/files_controller.ts
  - start/routes.ts
autonomous: true

must_haves:
  truths:
    - "ContentFile model exists with filename, storagePath, mimeType, size, checksum fields"
    - "FileStorageService can store files outside webroot with randomized names"
    - "FileStorageService retrieves files by ID and serves downloads"
    - "Duplicate files (same checksum) return existing record instead of creating new storage"
  artifacts:
    - path: "app/models/content_file.ts"
      provides: "ContentFile model with manyToMany to CourseContent"
      exports: ["default"]
      contains: "checksum"
    - path: "app/services/file_storage_service.ts"
      provides: "File storage with SHA-256 deduplication"
      exports: ["default"]
      contains: "computeChecksum"
    - path: "app/controllers/files_controller.ts"
      provides: "File download endpoint with path traversal protection"
      exports: ["default"]
      contains: "PATH_TRAVERSAL_REGEX"
    - path: "database/migrations/*_create_content_files_table.ts"
      provides: "content_files table with unique checksum constraint"
      contains: "checksum"
    - path: "database/migrations/*_create_content_content_files_table.ts"
      provides: "Pivot table for CourseContent-ContentFile relationship"
      contains: "content_content_files"
  key_links:
    - from: "app/services/file_storage_service.ts"
      to: "app/models/content_file.ts"
      via: "ContentFile.create() and ContentFile.findBy('checksum')"
      pattern: "ContentFile\\.(create|findBy)"
    - from: "app/controllers/files_controller.ts"
      to: "app/models/content_file.ts"
      via: "ContentFile.find(id)"
      pattern: "ContentFile\\.find"
    - from: "start/routes.ts"
      to: "app/controllers/files_controller.ts"
      via: "route registration"
      pattern: "FilesController.*download"
---

<objective>
Create the database models and file storage infrastructure for course content files

Purpose: This foundational infrastructure enables all content types (Page, File, URL) to store and deduplicate files. Without this, Phase 4 (File Content) cannot upload files, and Phase 3 (Page Content) cannot embed images.

Output:
- ContentFile model with checksum-based deduplication
- FileStorageService for secure file storage outside webroot
- FilesController for authorized file downloads
- Database migrations for content_files and pivot table
</objective>

<execution_context>
@C:\Users\vincent.delaleu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\vincent.delaleu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-content-foundation/01-RESEARCH.md

# Existing codebase patterns
@app/models/course_content.ts
@database/migrations/1763370568724_create_create_course_contents_table.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContentFile model and database migrations</name>
  <files>
    app/models/content_file.ts
    database/migrations/TIMESTAMP_create_content_files_table.ts
    database/migrations/TIMESTAMP_create_content_content_files_table.ts
  </files>
  <action>
1. Create ContentFile model at `app/models/content_file.ts`:
   - Fields: id, filename (string 255), storagePath (string 500), mimeType (string 100), size (bigint), checksum (string 64)
   - Timestamps: createdAt, updatedAt
   - Relationship: manyToMany to CourseContent via pivot table `content_content_files` with pivotTimestamps: true
   - Follow existing model patterns from course_content.ts (BaseModel, column decorators, DateTime from luxon)

2. Create migration for content_files table using `node ace make:migration create_content_files`:
   - id: increments primary key
   - filename: string(255) notNullable
   - storage_path: string(500) notNullable
   - mime_type: string(100) notNullable
   - size: bigInteger unsigned notNullable
   - checksum: string(64) notNullable with UNIQUE constraint (critical for deduplication)
   - timestamps: created_at notNullable, updated_at nullable
   - Index on checksum column for fast lookups

3. Create migration for pivot table using `node ace make:migration create_content_content_files`:
   - course_content_id: integer unsigned notNullable, references course_contents(id) onDelete CASCADE
   - content_file_id: integer unsigned notNullable, references content_files(id) onDelete CASCADE
   - Composite primary key on (course_content_id, content_file_id)
   - timestamps: created_at notNullable, updated_at nullable

4. Update CourseContent model to add manyToMany relationship to ContentFile:
   - Import ContentFile model
   - Add `files: ManyToMany<typeof ContentFile>` relationship with pivotTable: 'content_content_files', pivotTimestamps: true

5. Run migrations: `node ace migration:run`
  </action>
  <verify>
    - `node ace migration:status` shows both migrations as "completed"
    - `node ace repl` then `(await models.ContentFile).columnNames` returns expected columns
    - Database has content_files table with unique constraint on checksum
  </verify>
  <done>
    - ContentFile model exists with all fields (filename, storagePath, mimeType, size, checksum)
    - content_files table created with unique checksum constraint
    - content_content_files pivot table created
    - CourseContent has manyToMany relationship to ContentFile
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileStorageService with checksum deduplication</name>
  <files>
    app/services/file_storage_service.ts
    storage/content_files/.gitkeep
  </files>
  <action>
1. Create storage directory structure:
   - Create `storage/content_files/.gitkeep` to preserve directory in git
   - Add `storage/content_files/` to .gitignore (below .gitkeep line so .gitkeep is tracked but contents are not)

2. Create FileStorageService at `app/services/file_storage_service.ts`:

```typescript
import { createHash } from 'node:crypto'
import { createReadStream } from 'node:fs'
import { mkdir, unlink } from 'node:fs/promises'
import { join, dirname } from 'node:path'
import { cuid } from '@adonisjs/core/helpers'
import app from '@adonisjs/core/services/app'
import ContentFile from '#models/content_file'
import type { MultipartFile } from '@adonisjs/core/bodyparser'

export default class FileStorageService {
  private basePath: string

  constructor() {
    this.basePath = app.makePath('storage/content_files')
  }

  /**
   * Store a file with checksum-based deduplication.
   * If file with same checksum exists, returns existing record.
   */
  async store(file: MultipartFile): Promise<ContentFile> {
    if (!file.tmpPath) {
      throw new Error('File has no temporary path')
    }

    // Compute checksum from temp file
    const checksum = await this.computeChecksum(file.tmpPath)

    // Check for existing file with same checksum (deduplication)
    const existing = await ContentFile.findBy('checksum', checksum)
    if (existing) {
      // Clean up temp file since we won't use it
      await unlink(file.tmpPath).catch(() => {})
      return existing
    }

    // Generate storage path with sharding (first 2 chars of checksum)
    const storageName = `${cuid()}.${file.extname || 'bin'}`
    const prefix = checksum.substring(0, 2)
    const storagePath = join(prefix, storageName)
    const fullPath = join(this.basePath, prefix)

    // Ensure shard directory exists
    await mkdir(fullPath, { recursive: true })

    // Move file from temp to storage
    await file.move(fullPath, { name: storageName })

    // Create database record
    return ContentFile.create({
      filename: file.clientName,
      storagePath,
      mimeType: file.type ? `${file.type}/${file.subtype}` : 'application/octet-stream',
      size: file.size,
      checksum,
    })
  }

  /**
   * Get the full filesystem path for a ContentFile
   */
  getFullPath(file: ContentFile): string {
    return join(this.basePath, file.storagePath)
  }

  /**
   * Compute SHA-256 checksum using streams (handles large files)
   */
  private computeChecksum(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const hash = createHash('sha256')
      const stream = createReadStream(filePath)

      stream.on('data', (chunk) => hash.update(chunk))
      stream.on('end', () => resolve(hash.digest('hex')))
      stream.on('error', reject)
    })
  }
}
```

Key implementation details:
- Use Node.js native crypto (createHash) for SHA-256 - no external dependencies
- Use streaming for checksum computation to handle large files without memory issues
- Shard storage by first 2 chars of checksum to avoid filesystem limits
- Use cuid() for collision-resistant random filenames (already used in codebase)
- Handle case where file extension is missing (default to 'bin')
- Clean up temp file on deduplication hit
  </action>
  <verify>
    - File `app/services/file_storage_service.ts` exists
    - File `storage/content_files/.gitkeep` exists
    - `storage/content_files/` is in .gitignore
    - `bun run typecheck` passes with no errors in file_storage_service.ts
  </verify>
  <done>
    - FileStorageService can compute SHA-256 checksum
    - FileStorageService stores files in sharded directories (storage/content_files/{xx}/)
    - FileStorageService returns existing ContentFile when checksum matches (deduplication)
    - Storage directory structure exists with .gitkeep
  </done>
</task>

<task type="auto">
  <name>Task 3: Create FilesController and download route</name>
  <files>
    app/controllers/files_controller.ts
    start/routes.ts
  </files>
  <action>
1. Create FilesController at `app/controllers/files_controller.ts`:

```typescript
import type { HttpContext } from '@adonisjs/core/http'
import { normalize } from 'node:path'
import app from '@adonisjs/core/services/app'
import ContentFile from '#models/content_file'

// Detect path traversal attempts (../ or ..\)
const PATH_TRAVERSAL_REGEX = /\.\.[\\/]/

export default class FilesController {
  /**
   * Download a file by ID
   * GET /files/:id/download
   */
  async download({ params, response }: HttpContext) {
    const file = await ContentFile.find(params.id)

    if (!file) {
      return response.notFound({ message: 'File not found' })
    }

    // Security: prevent path traversal attacks
    const normalizedPath = normalize(file.storagePath)
    if (PATH_TRAVERSAL_REGEX.test(normalizedPath)) {
      return response.badRequest({ message: 'Invalid file path' })
    }

    const fullPath = app.makePath('storage/content_files', normalizedPath)

    // Serve file with original filename for download
    return response.download(fullPath, file.filename)
  }
}
```

Key security measures:
- Normalize path to handle platform differences
- Check for path traversal patterns (../ or ..\)
- Use response.download() which sets proper Content-Disposition header
- Return original filename so user sees meaningful name in download

2. Add route to `start/routes.ts`:
   - Add import: `const FilesController = () => import('#controllers/files_controller')`
   - Add route in appropriate section (near other resource routes):
   ```typescript
   router.get('/files/:id/download', [FilesController, 'download']).as('files.download')
   ```

Note: For Phase 1, the route is publicly accessible (no auth middleware). Authorization will be added in Phase 9 (Permissions and Polish) when we have enrollment context.
  </action>
  <verify>
    - `bun run typecheck` passes
    - `bun run dev` starts without errors
    - `curl http://localhost:3333/files/999/download` returns 404 JSON (file not found - expected for non-existent ID)
  </verify>
  <done>
    - FilesController exists with download action
    - Route GET /files/:id/download is registered
    - Path traversal protection is implemented
    - Files can be served for download by ID
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Database verification:**
   ```bash
   node ace migration:status
   # Both content_files and content_content_files migrations should show "completed"
   ```

2. **Model verification:**
   ```bash
   node ace repl
   # > (await models.ContentFile).columnNames
   # Should list: id, filename, storagePath, mimeType, size, checksum, createdAt, updatedAt
   ```

3. **Service verification (manual test in REPL):**
   ```bash
   node ace repl
   # > const fs = require('node:fs')
   # > fs.writeFileSync('tmp_test.txt', 'hello world')
   # > const { default: FileStorageService } = await import('#services/file_storage_service')
   # > const svc = new FileStorageService()
   # Service should instantiate without error
   ```

4. **Route verification:**
   ```bash
   curl -i http://localhost:3333/files/1/download
   # Should return 404 with JSON body (no files exist yet)
   ```

5. **Typecheck:**
   ```bash
   bun run typecheck
   # Should pass with no errors
   ```
</verification>

<success_criteria>
1. ContentFile model exists with all required fields (filename, storagePath, mimeType, size, checksum)
2. content_files table has unique constraint on checksum column
3. content_content_files pivot table enables many-to-many with CourseContent
4. FileStorageService computes SHA-256 checksums using streams
5. FileStorageService stores files in sharded directories (storage/content_files/{xx}/)
6. FileStorageService returns existing record when checksum matches (deduplication)
7. FilesController serves files for download with path traversal protection
8. Route GET /files/:id/download is registered
9. All typechecks pass
10. Migrations run successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-content-foundation/01-01-SUMMARY.md`
</output>
